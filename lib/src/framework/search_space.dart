import 'dart:math';

import 'package:exception_templates/exception_templates.dart';
import 'package:list_operators/list_operators.dart';

import '../extensions/random_in_range.dart';
import 'interval.dart';

/// A search region with boundaries defined by
/// `intervals`.
class SearchSpace {
  /// Constructs an object of type `SearchSpace`.
  /// * `intervals`: A list of intervals defining the search space.
  /// *  Note: Parametric intervals must be listed
  ///    **after** all intervals they depend on.
  SearchSpace(List<Interval> intervals)
      : _intervals = List<Interval>.of(intervals),
        dimensions = intervals.length;

  /// Search space dimensions.
  /// * Is equal to the length of the constructor parameter `intervals`.
  final int dimensions;

  /// Intervals defining the boundary of the sampling space.
  /// * The list `_intervals` must not be empty.
  final List<Interval> _intervals;

  /// Returns a random vector of length `dimension`. Each vector coordinate
  /// is generated by drawing samples from the corresponding
  /// interval.
  /// ---
  /// nGrid: Number of grid points along each dimension. An empty grid
  /// indicates a continuous search space.
  /// * If `nGrid[i] > 1`, the interval along dimension `i`
  ///   is divided into an equidistant grid.
  /// * `nGrid[i] = [xMin[i] + dx[i], xMin[i] + 2 * dx[i], ..., xMax[i] - dx[i]]`.
  /// * `dx[i] = (xMax[i] - xMin[i]) / nGrid[i]` and any random number returned
  ///   coincides with a gridpoint.
  List<num> next({List<int> nGrid = const <int>[]}) {
    try {
      _clearCache();
      return nGrid.isEmpty
          ? List<num>.generate(
              dimensions,
              (i) => _intervals[i].next(),
            )
          : List<num>.generate(
              dimensions,
              (i) => _intervals[i].next(nGrid: nGrid[i]),
            );
    } on RangeError catch (_) {
      throw ErrorOf<SearchSpace>(
          message: 'Could not generate random '
              'point using method next().',
          invalidState: 'Dimension mismatch: $dimensions != ${nGrid.length}.',
          expectedState: 'The vector \'nGrid\' must have length $dimensions.');
    }
  }

  /// Returns a random vector of length `dimension`
  /// sampled from the interval
  /// obtained by intersecting `this` with the generalized rectangle
  /// centred at `position` with edge lengths
  /// `(position - deltaPosition, position + deltaPosition)`.
  ///
  /// Note: If the intersection is empty, the input
  /// `position` is returned unperturbed.
  /// ---
  /// nGrid: Number of grid points along each dimension. An empty grid
  /// indicates a continuous search space.
  /// * If `nGrid[i] > 1`, the interval along dimension `i`
  ///   is divided into an equidistant grid.
  /// * `nGrid[i] = [xMin[i] + dx[i], xMin[i] + 2 * dx[i], ..., xMax[i] - dx[i]]`.
  /// * `dx[i] = (xMax[i] - xMin[i]) / nGrid[i]` and any random number returned
  ///   coincides with a gridpoint.
  /// Throws an error of type `ErrorOf<SearchSpace>` if the
  /// length of the `position` or `deltaPosition` does not match `this.dimension`.
  List<num> perturb(
    List<num> position,
    List<num> deltaPosition, {
    List<int> nGrid = const <int>[],
  }) {
    try {
      _clearCache();
      // Generating the random sample.
      return nGrid.isEmpty
          ? List<num>.generate(dimensions,
              (i) => _intervals[i].perturb(position[i], deltaPosition[i]))
          : List<num>.generate(
              dimensions,
              (i) => _intervals[i]
                  .perturb(position[i], deltaPosition[i], nGrid: nGrid[i]));
    } on RangeError catch (_) {
      if (position.length != dimensions) {
        throw ErrorOf<SearchSpace>(
            message: 'Could not generate random point around $position.',
            invalidState:
                'Dimension mismatch: $dimensions != ${position.length}.',
            expectedState: 'The vector position must have length $dimensions.');
      }
      if (deltaPosition.length != dimensions) {
        throw ErrorOf<SearchSpace>(
            message:
                'Could not generate perturbation using magnitudes $deltaPosition.',
            invalidState:
                'Dimension mismatch: $dimensions != ${deltaPosition.length}.',
            expectedState:
                'The vector deltaPosition must have length $dimensions.');
      }
      if (nGrid.isNotEmpty && nGrid.length != dimensions) {
        throw ErrorOf<SearchSpace>(
            message: 'Could not generate random point around $position.',
            invalidState: 'Dimension mismatch: $dimensions != ${nGrid.length}.',
            expectedState: 'The vector \'grid\' must have length $dimensions.');
      }
      rethrow;
    }
  }

  /// Clears the cached random numbers for each interval.
  void _clearCache() {
    for (final interval in _intervals) {
      interval.clearCache();
    }
  }

  /// Returns the search space size along each dimension.
  ///
  /// Note: For parametric intervals the size is estimated by sampling the
  /// interval 50 times and returning the difference between the sample
  /// maximum and the sample minimum.
  late final size = estimateSize().unmodifiable;

  /// Returns an estimate of the search space size.
  ///
  /// Note: If all intervals are of type `FixedInterval` the reported interval
  /// sizes are exact.
  List<num> estimateSize() {
    if (_intervals.every((interval) => interval is FixedInterval)) {
      return List<num>.generate(dimensions, (i) => _intervals[i].size);
    }

    final sizes = List<List<num>>.generate(50, (_) {
      _clearCache();
      return List<num>.generate(dimensions, (i) => _intervals[i].size);
    });

    return sizes.reduce((value, current) {
      for (var i = 0; i < dimensions; ++i) {
        value[i] = max(value[i], current[i]);
      }
      return value;
    });
  }

  /// Returns true if the point `position` belongs to the search space `this`.
  bool contains(List<num> position) {
    try {
      for (var i = 0; i < dimensions; ++i) {
        if (!_intervals[i].contains(position[i])) {
          return false;
        }
      }
      return true;
    } catch (e) {
      if (position.length != dimensions) {
        throw ErrorOf<SearchSpace>(
            message: 'Error encountered in method: \'contains($position)\'.',
            invalidState: 'Space dimension $dimensions != $position.length.',
            expectedState: 'The vector argument must have length $dimensions.');
      }
      rethrow;
    }
  }

  @override
  String toString() {
    final b = StringBuffer();
    b.writeln('Search Space: ');
    b.writeln('  size: $size');
    b.writeln('  dimension: $dimensions');
    for (var i = 0; i < dimensions; ++i) {
      b.writeln('  ${_intervals[i]}'.replaceAll('\n', '\n  '));
    }
    return b.toString();
  }

  /// Returns a list containing `size` points randomly
  /// sampled from the entire search space.
  List<List<num>> sample({
    int size = 2000,
    List<int> nGrid = const <int>[],
  }) =>
      List<List<num>>.generate(size, (_) => next(nGrid: nGrid));

  /// Returns a list containing `size` points randomly
  /// sampled from the vicinity of `position`.
  List<List<num>> sampleVicinityOf(
    List<num> position,
    List<num> deltaPosition, {
    int size = 600,
    List<int> nGrid = const <int>[],
  }) =>
      List<List<num>>.generate(
          size,
          (_) => perturb(
                position,
                deltaPosition,
                nGrid: nGrid,
              ));

  /// Returns a two-dimensional search space with triangular geometry.
  /// * Extends from `xMin` to `xMax` along the horizontal axis.
  /// * Has zero extent in y-direction if the first coordinate is `xMin`.
  /// * Extends from `yMin` to `yMax` if the first corrdinate is `xMax`.
  static SearchSpace triangle({
    num xMin = 0,
    num xMax = 10,
    num yMin = -150,
    num yMax = 150,
  }) {
    final x = FixedInterval(xMin, xMax, inverseCdf: InverseCdfs.triangular);

    num dx = xMax - xMin;
    return SearchSpace([
      x,
      ParametricInterval(
        () => yMin / dx * (x.next() - xMin),
        () => yMax / dx * (x.next() - xMin),
      ),
    ]);
  }

  /// Returns a three-dimensional search space with spherical
  /// geometry.
  /// ---
  /// * The sphere is centred at the origin.
  /// * The coordinates are specified as: `[r, theta, phi]` where
  /// `r` is the radius, `theta` is polar angle , and `phi` is angle formed
  /// by the x-axis and the projection of the point `[r, theta, phi]` onto
  /// the x-y plane.
  /// ---
  /// Usage:
  /// ```Dart
  /// // Creates a search space consisting of all points on the
  /// // surface of a sphere with unity radius.
  /// final space = SearchSpace.sphere(rMin = 1.0, rMax = 1.0);
  ///
  /// // Creates a list with 1000 points sampled from `space`.
  /// final sample = space.sample(size: 1000);
  /// ```
  static SearchSpace sphere({
    num rMin = 0,
    num rMax = 1,
    num thetaMin = 1e-4,
    num thetaMax = pi,
    num phiMin = 1e-4,
    num phiMax = 2 * pi,
  }) {
    // Define intervals.
    final r = FixedInterval(rMin, rMax);
    final theta = FixedInterval(
      thetaMin,
      thetaMax,
      inverseCdf: InverseCdfs.polarAngle,
    );
    final phi = (phiMin == phiMax)
        ? SingularInterval(phiMin)
        : PeriodicInterval(phiMin, phiMax);

    // Defining a spherical search space.
    return SearchSpace([r, theta, phi]);
  }

  /// Returns a search space with a box geometry.
  static SearchSpace box({
    num xMin = 0,
    num xMax = 1,
    num yMin = 0,
    num yMax = 1,
    num zMin = 0,
    num zMax = 1,
  }) =>
      SearchSpace([
        FixedInterval(xMin, xMax),
        FixedInterval(yMin, yMax),
        FixedInterval(zMin, zMax),
      ]);
}
