import 'dart:collection';
import 'dart:math';

import 'package:exception_templates/exception_templates.dart';
import 'package:list_operators/list_operators.dart';

import '../extensions/random_in_range.dart';
import 'interval.dart';

/// A search space defined by several by a list of [Interval]s.
class SearchSpace {
  /// Constructs an object of type `SearchSpace`.
  /// * `intervals`: A list of fixed intervals defining the search space.
  SearchSpace.fixed(List<FixedInterval> intervals, {this.name = ''})
      : dimensions = intervals.length,
        _intervals = List<FixedInterval>.generate(
          intervals.length,
          (index) => FixedInterval.of(intervals[index]),
        ),
        _order = List<int>.generate(
          intervals.length,
          (index) => index,
        );

  SearchSpace.parametric(List<Interval> intervals,
      {List<int> order = const <int>[], this.name = ''})
      : dimensions = intervals.length,
        _intervals = List<Interval>.generate(
          intervals.length,
          (index) => intervals[index],
        ),
        _order = order.isEmpty
            ? List<int>.generate(
                intervals.length,
                (index) => index,
              )
            : order;

  /// Intervals defining the boundary of the sampling space.
  /// * The list `_intervals` must not be empty.
  final List<Interval> _intervals;

  /// The search space name.
  final String name;

  /// The number of intervals that were used to define the
  /// [SearchSpace].
  final int dimensions;

  /// Set the levels (number of grid points) for each interval.
  ///
  /// Throws an error of type [ErrorOf<SearchSpace] if the length
  /// of [value] is not [dimensions].
  set levels(List<int> value) {
    if (value.length != dimensions) {
      throw ErrorOf<SearchSpace>(
        message: 'Error in setter <levels>.',
        expectedState: 'A list of integers with length $dimensions.',
        invalidState: 'Found a list of integer with length ${value.length}.',
      );
    }
    for (var i = 0; i < dimensions; i++) {
      _intervals[i].levels = value[i];
    }
  }

  /// Returns a list of integers containing the number of grid points
  /// for each interval.
  ///
  /// Note: An interval is considered discrete if it has at least two
  /// grid points.
  List<int> get levels => List<int>.generate(
        dimensions,
        (i) => _intervals[i].levels,
      );

  /// Unvalidated order.
  final List<int> _order;

  /// Normal order.
  late final UnmodifiableListView<int> normalOrder =
      UnmodifiableListView(List<int>.generate(
    dimensions,
    (index) => index,
  ));

  /// Validates the parameter [order] before it is used for the first time.
  List<int> validOrder() {
    if ((List.of(_order)..sort()).equal(normalOrder)) {
      return _order;
    } else {
      throw ErrorOf<SearchSpace>(
          message: 'The parameter <order> is invalid.',
          expectedState: 'A permutation of the normal order: $normalOrder',
          invalidState: 'Instead found order = $_order.');
    }
  }

  /// Order in which intervals are evaluated in the
  /// methods [next] and [perturb].
  late final List<int> order = validOrder();

  /// Returns `true` if [order] does not compare
  /// [equal] to [normalOrder].
  late final hasCustomOrder = !normalOrder.equal(_order);

  /// Marks cached random numbers for each interval as stale.
  void _updateCache() {
    for (final interval in _intervals) {
      interval.updateCache();
    }
  }

  /// Returns a random vector of length `dimension`. Each vector coordinate
  /// is generated by drawing a sample from the corresponding
  /// interval.
  List<num> next() {
    _updateCache();
    if (hasCustomOrder) {
      final result = List<num>.filled(dimensions, 0.0);
      // The list `order` contains a permutation of all indices.
      for (var i in order) {
        result[i] = _intervals[i].next();
      }
      return result;
    } else {
      return List<num>.generate(
        dimensions,
        (i) => _intervals[i].next(),
      );
    }
  }

  /// Returns a random vector of length [dimensions]
  /// sampled from the interval
  /// obtained by intersecting `this` with the generalized rectangle
  /// centred at [position] with edge lengths
  /// `(position - deltaPosition, position + deltaPosition)`.
  ///
  /// Note: If the intersection along a certain interval is empty then the
  /// corrsponding coordinate is set to [double.nan].
  /// ---
  /// Throws an error of type [ErrorOf<SearchSpace>] if the
  /// length of the [position] or [deltaPosition] does not match [dimensions].
  List<num> perturb(List<num> position, List<num> deltaPosition) {
    _updateCache();
    try {
      if (hasCustomOrder) {
        final result = List<num>.filled(dimensions, 0.0);
        for (var i in order) {
          result[i] = _intervals[i].perturb(position[i], deltaPosition[i]);
        }
        return result;
      } else {
        return List<num>.generate(dimensions,
            (i) => _intervals[i].perturb(position[i], deltaPosition[i]));
      }
    } on RangeError catch (_) {
      if (position.length != dimensions) {
        throw ErrorOf<SearchSpace>(
            message: 'Could not generate random point around $position.',
            invalidState:
                'Dimension mismatch: $dimensions != ${position.length}.',
            expectedState: 'The vector position must have length $dimensions.');
      }
      if (deltaPosition.length != dimensions) {
        throw ErrorOf<SearchSpace>(
            message:
                'Could not generate perturbation using magnitudes $deltaPosition.',
            invalidState:
                'Dimension mismatch: $dimensions != ${deltaPosition.length}.',
            expectedState:
                'The vector deltaPosition must have length $dimensions.');
      }
      rethrow;
    }
  }

  /// Returns a list containing the interval size along each space dimension.
  late final size = _estimateSize().unmodifiable;

  // late final sizes = List<num>.generate(dimensions, (i) {
  //   _updateCache();
  //   return _intervals[i].size;
  // });

  /// Returns an estimate of the search space size.
  ///
  /// Note: If all intervals are of type `FixedInterval` the reported interval
  /// sizes are exact.
  List<num> _estimateSize() {
    final parametricIndexes = <int>[];
    final sizes = List<num>.generate(dimensions, (i) {
      if (_intervals[i] is FixedInterval) {
        return _intervals[i].size;
      } else {
        parametricIndexes.add(i); // Keep track of parametric intervals.
        return -1;
      }
    });

    if (parametricIndexes.isEmpty) return sizes;

    /// Recalculate the size of parametric intervals
    /// retaining the largest value.
    int n = 0;
    do {
      n++;
      _updateCache(); // Recalculate all random numbers.
      for (var i in parametricIndexes) {
        sizes[i] = max(sizes[i], _intervals[i].size);
      }
    } while (n < 100);

    return sizes;
  }

  /// Returns `true` if the point [position] belongs to the search space `this`.
  bool contains(List<num> position) {
    try {
      for (var i in order) {
        if (!_intervals[i].contains(position[i])) {
          return false;
        }
      }
      return true;
    } catch (e) {
      if (position.length != dimensions) {
        throw ErrorOf<SearchSpace>(
            message: 'Error encountered in method: \'contains($position)\'.',
            invalidState: 'Space dimension $dimensions != $position.length.',
            expectedState: 'The vector argument must have length $dimensions.');
      }
      rethrow;
    }
  }

  /// Returns a list containing `sampleSize` points randomly
  /// sampled from the entire search space.
  List<List<num>> sample({
    int sampleSize = 2000,
  }) =>
      List<List<num>>.generate(sampleSize, (_) => next());

  /// Returns a list containing [sampleSize] points randomly
  /// sampled from the vicinity of [position].
  /// * The size of the neighbourhood around [position] is given by
  /// [deltaPosition].
  List<List<num>> sampleCloseTo(List<num> position, List<num> deltaPosition,
          {int sampleSize = 600}) =>
      List<List<num>>.generate(
          sampleSize,
          (_) => perturb(
                position,
                deltaPosition,
              ));

  @override
  String toString() {
    final b = StringBuffer();
    b.writeln('SearchSpace: ');
    b.writeln('  name: $name');
    b.writeln('  size: $size');
    b.writeln('  dimensions: $dimensions');
    b.writeln('  intervals:');
    for (var i = 0; i < dimensions; ++i) {
      b.writeln('    $i: ${_intervals[i]}'.replaceAll('\n', '\n    '));
    }
    return b.toString();
  }

  /// Returns a three-dimensional search space with spherical
  /// geometry.
  /// ---
  /// * The sphere is centred at the origin.
  /// * The coordinates are specified as: `[r, theta, phi]` where
  /// `r` is the radius, `theta` is polar angle , and `phi` is angle formed
  /// by the x-axis and the projection of the point `[r, theta, phi]` onto
  /// the x-y plane.
  /// ---
  /// Usage:
  /// ```Dart
  /// // Creates a search space consisting of all points on the
  /// // surface of a sphere with unity radius.
  /// final space = SearchSpace.sphere(rMin = 1.0, rMax = 1.0);
  ///
  /// // Creates a list with 1000 points sampled from `space`.
  /// final sample = space.sample(size: 1000);
  /// ```
  static SearchSpace sphere({
    num rMin = 0,
    num rMax = 1,
    num thetaMin = 0,
    num thetaMax = pi,
    num phiMin = 0,
    num phiMax = 2 * pi,
  }) {
    // Define intervals.
    final r = FixedInterval(
      rMin,
      rMax,
      name: 'radius <r>',
      inverseCdf: InverseCdfs.r,
    );
    final theta = FixedInterval(
      thetaMin,
      thetaMax,
      inverseCdf: InverseCdfs.polarAngle,
      name: 'polar angle <theta>',
    );
    final phi = (phiMin == phiMax)
        ? SingularInterval(phiMin, name: 'azimuth <phi>')
        : PeriodicInterval(phiMin, phiMax, name: 'azimuth <phi>');

    // Defining a spherical search space.
    return SearchSpace.fixed([r, theta, phi], name: 'sphere');
  }

  /// Returns a two dimensional search space with disk geometry.
  /// * A circular geometry can be achieved by setting `rhoMin == rhoMax`.
  static SearchSpace disk({
    num rhoMin = 0,
    num rhoMax = 1,
    num phiMin = 0,
    num phiMax = 2 * pi,
  }) {
    // Define intervals.
    final r = FixedInterval(rhoMin, rhoMax, inverseCdf: InverseCdfs.rho);
    final phi = (phiMin == phiMax)
        ? SingularInterval(phiMin)
        : (phiMax - phiMin) == 2 * pi
            ? PeriodicInterval(phiMin, phiMax)
            : FixedInterval(phiMin, phiMax);

    // Defining a spherical search space.
    return SearchSpace.fixed([r, phi]);
  }

  /// Returns a search space with cylindrical geometry.
  static SearchSpace cylinder({
    num rhoMin = 0,
    num rhoMax = 1,
    num phiMin = 0,
    num phiMax = 2 * pi,
    num zMin = 0,
    num zMax = 1,
  }) {
    // Define intervals.
    final r = FixedInterval(rhoMin, rhoMax, inverseCdf: InverseCdfs.rho);

    late final FixedInterval phi;
    if ((phiMax - phiMin) == 2 * pi) {
      print('Periodic...');
      phi = PeriodicInterval(phiMin, phiMax);
    } else {
      phi = FixedInterval(phiMin, phiMax);
    }
    final z = FixedInterval(zMin, zMax);
    // Defining a spherical search space.
    return SearchSpace.fixed([r, phi, z]);
  }

  /// Returns a search space with rectangular geometry.
  static SearchSpace rectangle({
    num xMin = 0,
    num xMax = 2,
    num yMin = 0,
    num yMax = 1,
  }) =>
      SearchSpace.fixed([
        FixedInterval(xMin, xMax),
        FixedInterval(yMin, yMax),
      ]);

  /// Returns a search space with a box geometry.
  static SearchSpace box({
    num xMin = 0,
    num xMax = 1,
    num yMin = 0,
    num yMax = 1,
    num zMin = 0,
    num zMax = 1,
  }) =>
      SearchSpace.fixed([
        FixedInterval(xMin, xMax),
        FixedInterval(yMin, yMax),
        FixedInterval(zMin, zMax),
      ]);

  /// Returns a two-dimensional search space with triangular geometry.
  /// * Extends from `xMin` to `xMax` along the horizontal axis.
  /// * Has zero extent in y-direction if the first coordinate is `xMin`.
  /// * Extends from `yMin` to `yMax` if the first corrdinate is `xMax`.
  static SearchSpace triangle({
    num xMin = 0,
    num xMax = 10,
    num yMin = -150,
    num yMax = 150,
  }) {
    final x = FixedInterval(xMin, xMax, inverseCdf: InverseCdfs.triangular);

    num dx = xMax - xMin;
    return SearchSpace.parametric([
      x,
      ParametricInterval(
        () => yMin / dx * (x.next() - xMin),
        () => yMax / dx * (x.next() - xMin),
      ),
    ]);
  }

  /// Returns a two dimensional [SearchSpace] with a
  /// disk geometry defined in terms of Cartesion coordinates `[x, y]`.
  static SearchSpace diskCartesian(num radius) {
    final x = FixedInterval(-radius, radius);
    final r2 = radius * radius;
    final y = ParametricInterval(
      () => -sqrt(r2 - pow(x.next(), 2)),
      () => sqrt(r2 - pow(x.next(), 2)),
    );

    return SearchSpace.parametric([x, y]);
  }

  /// Returns a three-dimensional search space with spherical
  /// geometry.
  /// ---
  /// * The sphere is centred at [centre].
  /// * The coordinates are specified as: `[x, y, z]` where
  static SearchSpace sphereCartesian({
    num radius = 1.0,
    List<num> centre = const <double>[0.0, 0.0, 0, 0],
  }) {
    // Define intervals.
    final x0 = centre[0];
    final y0 = centre[1];
    final z0 = centre[2];
    final x = FixedInterval(
      x0 - radius,
      x0 + radius,
    );
    final y = ParametricInterval(
      () =>
          y0 -
          sqrt(
            pow(radius, 2) - pow(x.next() - x0, 2),
          ),
      () =>
          y0 +
          sqrt(
            pow(radius, 2) - pow(x.next() - x0, 2),
          ),
    );
    final z = ParametricInterval(
      () =>
          z0 -
          sqrt(
            pow(radius, 2) - pow(y.next() - y0, 2) - pow(x.next() - x0, 2),
          ),
      () =>
          z0 +
          sqrt(
            pow(radius, 2) - pow(y.next() - y0, 2) - pow(x.next() - x0, 2),
          ),
    );
    return SearchSpace.parametric([x, y, z], order: []);
  }

  static SearchSpace cone({
    num rhoMin = 0,
    num rhoMax = 2,
    num phiMin = 0,
    num phiMax = 2 * pi,
    num zMin = 0,
    num zMax = 2,
  }) {
    // Define intervals.
    final z = FixedInterval(zMin, zMax, inverseCdf: InverseCdfs.triangular);
    final phi = PeriodicInterval(phiMin, phiMax);

    // /// Radius as a function of the vertical coordinate.
    // num rhoParam(num z) {
    //   return (-z * (rhoMax - rhoMin) + rhoMax * zMax - rhoMin * zMin) /
    //       (zMax - zMin);
    // }

    final rho = ParametricInterval(
      () => 0,
      () => z.next() * rhoMax / (rhoMax - rhoMin),
      inverseCdf: InverseCdfs.triangular,
    );

    return SearchSpace.parametric([rho, phi, z], order: [2, 1, 0]);
  }
}
